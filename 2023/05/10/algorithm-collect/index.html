<!DOCTYPE html>
<html>
	<head>
		
<title>前端常见算法汇总（JS）-Jia</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" type="image/x-icon" href="/image/favicon.ico">

<link rel="stylesheet" href="/css/index.css">



<meta name="keywords" content="算法,">
<meta name="description" content="">


<script src="/js/jquery.min.js"></script>


<script src="/js/index.js"></script>


<script src="/js/fancybox.umd.js"></script>


<script src="/js/fancybox-images.js"></script>


<script src="/js/gitalk.min.js"></script>


<script src="/js/hljs.min.js"></script>
 
<script>hljs.highlightAll();</script>

	<meta name="generator" content="Hexo 5.4.2"></head>

	<body>
		
	<div class="header">
		<div class="header-top" id="header-top">
			<div class="h-left">
				<a href="/">
					<img src="/image/logo.png" alt="Quiet">
				</a>
			</div>
			<div class="h-right">
				<ul>
					
						
								<li>
									<a href="/">
										ARTICLE
									</a>
									<span class="dot"></span>
								</li>
								
									
				</ul>
			</div>
			<div class="h-right-close">
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
					<path fill="none" d="M0 0h24v24H0z" />
					<path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z" fill="rgba(68,68,68,1)" />
				</svg>
			</div>
		</div>
	</div>
	<div class="sidebar">
    <div class="topo">
        <h2>Jia</h2>
    </div>
    <ul>
        
        <li>
            <a href="/">ARTICLE</a>
        </li>
        
    </ul>
    <div class="my_foot">
        
        <a href="">
            <img src="/image/logo.png" alt="Quiet主题">
        </a>
        
    </div>
</div>
<div class='shelter'>
</div>
<style>
    .shelter{
        background-color: #333;
        opacity:0.5;
        cursor: pointer;
        display: none; 
        position: fixed;
        left: 0;
        top: 0; 
        right: 0;
        bottom: 0;
        z-index: 1998;
    }
    .sidebar {
        width: 66%;
        height: 100%;
        position: fixed;
        top: 0;
        right: -100%;
        bottom: 0;
        background: #fff;
        z-index: 1999;
        text-align: center;
        box-shadow: -6px 0 20px rgba(98, 94, 94, .815);
    }

    .topo {
        width: 100%;
        height: 200px;
        background: url(https://api.ixiaowai.cn/gqapi/gqapi.php) no-repeat;
        background-size: 100% 100%;
        position: relative;
        display: flex;
        align-items: flex-end
    }

    .topo h2 {
        color: #fff;
        z-index: 1;
        position: relative;
        margin: 0 0 10px 10px;
        font-size: 1.2em;
        box-sizing: border-box
    }

    .topo:before {
        content: '';
        background-image: url(/image/pattern.png);
        background-repeat: repeat;
        height: 100%;
        left: 0;
        position: absolute;
        top: 0;
        width: 100%;
        z-index: 1
    }

    .sidebar ul {
        width: 100%;
        margin-top: 50px
    }

    .sidebar ul li {
        height: 50px;
        list-style: none;
        font-size: 1.2em;
        text-align: right;
        margin-right: 10px
    }

    .sidebar ul li a {
        display: grid;
        color: #5d606a;
        text-overflow: ellipsis;
        width: 100%;
        text-decoration: none
    }

    .my_foot {
        width: 100%;
        padding: 10px;
        margin-bottom: 10px;
        position: absolute;
        bottom: 0
    }

    .my_foot a {
        text-decoration: none;
        margin-right: 10px;
        display: inline-block
    }

    .my_foot a img {
        width: 30px;
        height: 30px
    }
</style>

<script>
    $( function () {
	$( '.h-right-close>svg' )
		.click( function () {
			$( '.sidebar' )
				.animate( {
					right: "0"
				}, 500 );
			$( '.shelter' )
				.fadeIn( "slow" )
		} );
	$( '.shelter' )
		.click( function ( e ) {
			$( '.sidebar' )
				.animate( {
					right: "-100%"
				}, 500 );
			$( '.shelter' )
				.fadeOut( "slow" )
		} )
} )

</script>

<div class="post">
    <div class="post-header-background post-header-img">
<!-- style="background: url('https://api.ixiaowai.cn/gqapi/gqapi.php')" -->
    <div class="post-header-background-content">
        <ul class="post-header-tag">
            
            
            <li><a href="/tags/算法">算法</a></li>
            
            
        </ul>
        
        <h1>前端常见算法汇总（JS）</h1>
        <div class="post-header-info">
            <div class="post-header-info-author">
                
                    <svg t="1604839279282" class="icon" viewBox="0 0 1024 1024" version="1.1"
                        xmlns="http://www.w3.org/2000/svg" p-id="2901" width="20" height="20">
                        <path
                            d="M513 956.3c-247.7 0-448-200.3-448-448S265.3 66.2 513 66.2s448 200.3 448 448-200.3 442.1-448 442.1z m0-830.9c-212.2 0-388.8 170.7-388.8 388.8C124.2 726.3 294.9 903 513 903c212.2 0 388.8-170.7 388.8-388.8S725.2 125.4 513 125.4z m0 430.2c-94.2 0-170.7-76.5-170.7-170.7S418.8 207.8 513 207.8s170.7 76.5 170.7 170.7S607.2 555.6 513 555.6z m0-289.1c-64.6 0-112 52.8-112 112s47.4 117.9 112 117.9 112-52.8 112-112-47.4-117.9-112-117.9z m0 689.8c-135.7 0-259-58.7-341.9-158.9l-11.8-17.8 11.8-17.8c76.5-117.9 206.2-188.5 347.8-188.5 135.7 0 265 64.6 341.9 182.6l11.8 17.8-11.8 17.8C778 897.1 648.7 956.3 513 956.3zM230.3 773.2C300.9 849.7 406.9 897 513 897c112 0 218.1-47.4 288.6-129.8-70.5-88.2-170.7-135.6-282.7-135.6s-218.1 53.3-288.6 141.6z"
                            p-id="2902" fill="#ffffff"></path>
                    </svg>
                    
                <span class="post-header-info-author-text"> <a href="../../about">Jia</a></span>
                <!-- <div class="post-header-info-author-categories">
                    
                         <a href="../../categories/算法/" target="_blank" >算法</a>
                    
                </div> -->
                <p>2023-05-10 19:20:34</p>
            </div>
        </div>
    </div>
</div>
    <div class="post-content" id="content">
  
  <div id="article" class="post-content-info">
    

    <h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p><strong>概念类简述：</strong></p>
<ol>
<li>数据线性排列，每个数据都有 1 个指针，指针指向下一个数据内存地址。</li>
<li>链表概念图：a–&gt;b–&gt;c</li>
<li>数据访问耗时：链表是分散存储，顺序访问的：要想访问某数据，需从第 1 个数据顺着指针向下访问</li>
<li>数据新增/删除方便：链表新增/删除只需改变指针指向就可以了</li>
<li>时间复杂度：新增/删除 O(1)，访问 O(n)</li>
<li>拓展：循环链表、双向链表</li>
</ol>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>概念类简述：</strong></p>
<ol>
<li>数据访问方便：存储连续空间，数据都有对应内存地址，可以通过 arr[i] 随机访问某个数据</li>
<li>新增/删除耗时：需要移动数据，挪出位置</li>
<li>时间复杂度：新增/删除 O(n)，访问 O(1)</li>
</ol>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><strong>概念类简述：</strong></p>
<ol>
<li>线性排列数据结构，后进先出</li>
</ol>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p><strong>概念类简述：</strong></p>
<ol>
<li>线性排列数据结构，先进先出</li>
</ol>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><strong>概念类简述：</strong></p>
<ol>
<li>哈希表存储的是 key-value 形式的数据</li>
<li>哈希表可解决线性查找耗时问题</li>
<li>存储数据：例如: {bom: man}，数组长度为 5<ul>
<li>bom 通过哈希函数计算哈希值为 5278，用 5278 对数组长度 5 取余得 3，所以将 bom 放在 3 号箱，如 3 号箱已有数据（存在冲突），则在 3 号箱使用链表（链地址法），线性存储</li>
<li>解决冲突有链地址法、开放地址法（应用较广泛，存在冲突就在数组上不断计算出候补位置存放）</li>
</ul>
</li>
</ol>
<img src="img-1.png" width=100% height=200 alt=alt />

<ol start="4">
<li><p>查找数据 bom：计算 bom 哈希值然后 mod 5 得到 3, 在 3 号箱进行线性查找</p>
</li>
<li><p>哈希表给数组设定合适的空间很重要，空间大，容易浪费，空间小，容易冲突，线性查找时间长</p>
</li>
</ol>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><strong>概念类简述：</strong></p>
<ol>
<li>堆是一种图的树形结构，被用于实现优先队列（自由添加数据，从最小值按顺序取出），适用频繁取最小值</li>
<li>堆每个节点最多两个子节点，节点排序为从上到下，从左到右</li>
<li>子节点必定大于父节点，添加/删除</li>
<li>取最小值（顶端）O(1)，添加/取值 O(logn)</li>
</ol>
<img src="img-2.png" width=100% height=200 alt=alt />

<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p><strong>概念类简述：</strong></p>
<ol>
<li>每个节点最多 2 子节点</li>
<li>性质：（1）每个节点值必大于其左子树任一节点值；（2）每个节点值必小于其右子树任一节点值</li>
<li>顶点开始沿左下末端查找查最小值，右下末端查找最大值</li>
<li>树均衡 O(logn)，单侧树 O(n)</li>
</ol>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><img src="img-3.png" width=100% height=400 alt=alt />

<h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><p>思想-相邻比较大小：比较所有相邻的两个项，如果第一个比第二个大，则交换它们<br>时间复杂度：O(n2)<br>实现思路：</p>
<ol>
<li>比较相邻的两个元素，如果前一个比后一个大，则交换位置；</li>
<li>比较完第一轮后，最大的元素在最右边，该元素不参与下一轮比较；</li>
<li>回到步骤一，直至对比完所有元素；</li>
</ol>
<img src="img-4.gif" width=100% height=200 alt=alt />

<pre><code class="javascript">function bubbleSort(arr) &#123;
  for (let i = 0; i &lt; arr.length; i++) &#123;
    for (let j = 0; j &lt; arr.length - 1 - i; j++) &#123;
      if (arr[j] &gt; arr[j + 1]) &#123;
        // let temp = arr[j];
        // arr[j] = arr[j+1];
        // arr[j+1] = temp;
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      &#125;
    &#125;
  &#125;
  return arr;
&#125;
console.log(bubbleSort([15, 1, 62, 25, 11]));
</code></pre>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>思想-找最小值：从待排序数据中寻找最小值（线性查找），将其与序列最左边数字进行交换；<br>时间复杂度：O(n2)<br>实现思路：</p>
<ol>
<li>设当前最小值及其索引为第 n（n 从 0 开始） 个数；</li>
<li>如果 n+1 的值比 n 小，则将 n+1 作为当前最小值及最小值索引；</li>
<li>第一轮结束后，将得到的最小值和待排序序列最左边的数字交换；</li>
<li>回到步骤一，直至对比完所有元素；</li>
</ol>
<img src="img-5.png" width=100% height=100 alt=alt />

<img src="img-6.png" width=100% height=100 alt=alt />

<pre><code class="javascript">function selectSort(arr) &#123;
  for (let i = 0; i &lt; arr.length - 1; i++) &#123;
    let min = arr[i];
    let index = i;
    for (let j = i + 1; j &lt; arr.length; j++) &#123;
      if (min &gt; arr[j]) &#123;
        min = arr[j];
        index = j;
      &#125;
    &#125;
    [arr[i], arr[index]] = [min, arr[i]];
  &#125;
  return arr;
&#125;
console.log(selectSort([15, 1, 62, 25, 11]));
</code></pre>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>思想：从右侧未排序区域取一个数据将它插入到已排序区域内合适的位置；<br>时间复杂度：O(n2)<br>实现思路：</p>
<ol>
<li>从第一个元素开始，该元素默认为已被排序；</li>
<li>取出下一个元素 A，在已排序序列中从后向前扫描；</li>
<li>如果 A 大于已归位数字 n 则交换两个数字，直至 A 小于已归位数字 n，结束一轮排序；</li>
<li>回到步骤 2，直至对比完所有元素；</li>
</ol>
<pre><code class="javascript">function insertSort(arr) &#123;
  for (let i = 1; i &lt; arr.length; i++) &#123;
    let index = i;
    let currentValue = arr[i];
    while (index &gt; 0 &amp;&amp; currentValue &lt; arr[index - 1]) &#123;
      arr[index] = arr[index - 1]; // 移位
      index--;
    &#125;
    arr[index] = currentValue;
  &#125;
  return arr;
&#125;
console.log(insertSort([15, 1, 62, 25, 11]));
</code></pre>
<h3 id="堆-1"><a href="#堆-1" class="headerlink" title="堆"></a>堆</h3><p>思想：按降序用数据构建堆，然后从堆的顶点依次取值<br>时间复杂度：O（nlogn）<br>实现思路</p>
<img src="img-7.png" width=100% height=200 alt=alt />

<img src="img-8.png" width=100% height=200 alt=alt />

<h3 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h3><p>思想-先分后合：分-将序列不断折中分成两个序列，直至每个序列只有一个数据停止，归并-将两个排好序的序列合成一个序列，直至只有一个序列停止<br>时间复杂度：O（nlogn）<br>实现思路</p>
<ol>
<li>将数组以 n/2 为中心分成两个子序列；</li>
<li>回到步骤 1（递归），直至子序列长度均为 1；</li>
<li>从长度为 1 的子序列开始，从下往上排序归并；</li>
<li>回到步骤 3（递归），直至子序列长度均为 1；</li>
</ol>
<img src="img-9.png" width=100% height=200 alt=alt />

<img src="img-10.png" width=100% height=200 alt=alt />

<pre><code class="javascript">const arr = [1, 6, 7, 8, 9, 3, 5, 4, 2];

function mergeSort(arr) &#123;
  if (arr.length &lt;= 1) &#123;
    return arr;
  &#125;
  const middleIndex = Math.floor(arr.length / 2);
  const leftArr = arr.slice(0, middleIndex);
  const rightArr = arr.slice(middleIndex);
  return merge(mergeSort(leftArr), mergeSort(rightArr));
&#125;

function merge(leftArr, rightArr) &#123;
  let sortArr = [];

  while (leftArr.length &gt; 0 &amp;&amp; rightArr.length &gt; 0) &#123;
    if (leftArr[0] &lt;= rightArr[0]) &#123;
      sortArr.push(leftArr.shift());
    &#125; else &#123;
      sortArr.push(rightArr.shift());
    &#125;
  &#125;

  if (leftArr.length) &#123;
    sortArr = sortArr.concat(leftArr);
  &#125;
  if (rightArr.length) &#123;
    sortArr = sortArr.concat(rightArr);
  &#125;
  return sortArr;
&#125;

console.log(mergeSort(arr));
</code></pre>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>思想-“分治法”：随机选择 1 基准值，比基准值小的放在基准值左边，大的放右边，不断重复此操作，直至排序完成；如：[比基准值小的数] 基准值 [比基准值大的数]<br>时间复杂度：每次基准值分离的子序列为原来一般O（nlogn），每次基准值为最小值O（n2）<br>实现思路</p>
<ol>
<li>以一个数为基准（通常是中间的数），比基准小的放到左边，比基准大的放到右边；</li>
<li>将上述左边和右边的数据分别递归快排，将处理后的数据和基准值合并成一个新数组，返回；</li>
</ol>
<p>原数据：3 5 8 1 2 9 4 7 6</p>
<img src="img-11.png" width=100% height=150 alt=alt />

<pre><code class="javascript">function quickSort(arr) &#123;
  if (arr.length &lt;= 1) &#123;
    return arr;
  &#125;

  let pivotIndex = Math.floor(arr.length / 2);
  let pivot = arr.splice(pivotIndex, 1)[0];
  let left = [];
  let right = [];
  for (let i = 0; i &lt; arr.length; i++) &#123;
    if (arr[i] &lt; pivot) &#123;
      left.push(arr[i]);
    &#125; else &#123;
      right.push(arr[i]);
    &#125;
  &#125;
  return quickSort(left).concat([pivot], quickSort(right));
&#125;
console.log(&#39;quickSort result: &#39;, quickSort([15, 1, 62, 25, 11]));
</code></pre>
<h2 id="数组的查找"><a href="#数组的查找" class="headerlink" title="数组的查找"></a>数组的查找</h2><h3 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h3><p><strong>概念类简述：</strong></p>
<ol>
<li>在数组中查找数据的算法，从头开始依次往下不断的检查数据是否是目标数据</li>
<li>时间复杂度 O(n)</li>
</ol>
<pre><code class="javascript">const arr = [1, 6, 7, 8, 9, 3, 5, 4, 2];
function linear(arr, number) &#123;
  for (let i = 0; i &lt; arr.length; i++) &#123;
    if (arr[i] === number) &#123;
      return `index:$&#123;i&#125;; value:$&#123;arr[i]&#125;`;
    &#125;
  &#125;
  // -1 代表没找到
  return -1;
&#125;
console.log(linear(arr, 1));
</code></pre>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><strong>概念类简述：</strong></p>
<ol>
<li>在数组中查找数据的算法，只能查找已排好序的数据</li>
<li>通过比对目标数据与数组中间数据大小，判断目标数据在中间的左边还是右边，不断缩小目标范围，直至找到数据或数据不存在</li>
<li>时间复杂度 O(logn)</li>
</ol>
<img src="img-12.png" width=100% height=150 alt=alt />

<pre><code class="javascript">const arr = [1, 6, 7, 1, 9, 3, 5, 4, 2];

function sort(arr) &#123;
  return arr.sort();
&#125;

const sortArr = sort(arr);

// 利用递归
function binary(sortArr, number) &#123;
  if (sortArr.length &lt;= 1) &#123;
    return sortArr[0] === number ? sortArr[0] : -1;
  &#125;

  const middleIndex = Math.floor(sortArr.length / 2);

  if (number === sortArr[middleIndex]) &#123;
    return sortArr[middleIndex];
  &#125;

  if (number &lt; sortArr[middleIndex]) &#123;
    return binary(sortArr.slice(0, middleIndex), number);
  &#125; else &#123;
    return binary(sortArr.slice(middleIndex + 1), number);
  &#125;
&#125;
console.log(binary(sortArr, 1), &quot;uuu&quot;);
</code></pre>
<h2 id="图的搜索"><a href="#图的搜索" class="headerlink" title="图的搜索"></a>图的搜索</h2><p><strong>概念类简述：</strong></p>
<ol>
<li>常用于解决最短路径问题</li>
</ol>
<img src="img-13.png" width=100% height=150 alt=alt />

<img src="img-14.png" width=100% height=150 alt=alt />

<h3 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h3><p><strong>概念类简述：</strong></p>
<ol>
<li>候补顶点用“先入先出”队列来管理</li>
<li>起点开始，由近到远进行广泛搜索，目标数据离顶点越近，搜索结束越快</li>
</ol>
<p>实现思路：</p>
<ol>
<li>定义变量数组储存依次遍历的节点</li>
<li>用 while + forEach，不断遍历向变量中 push 后续查找的节点</li>
<li>找到目标值，中断查找</li>
<li>所有节点都遍历玩为找到目标值，返回 -1</li>
</ol>
<img src="img-15.png" width=100% height=200 alt=alt />

<img src="img-16.png" width=100% height=200 alt=alt />

<pre><code class="javascript">const &#123; tree &#125; = require(&quot;../../assets/mock/index&quot;);

// 利用队列先进先出的思想
function breadthFirst(treeObj, target) &#123;
  if (!treeObj) return;

  const searchStep = [];
  const queue = [treeObj];
  while (queue.length) &#123;
    const currentNode = queue.shift();
    const &#123; name, children &#125; = currentNode;
    searchStep.push(name);
    if (name === target) &#123;
      return &#123; name, searchStep &#125;;
    &#125;
    children.forEach((child) =&gt; queue.push(child));
  &#125;
  return -1;
&#125;

console.log(breadthFirst(tree, &quot;G&quot;));
</code></pre>
<h3 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h3><p><strong>概念类简述：</strong></p>
<ol>
<li>从顶点沿一条路径不断往下搜索至路径终点，折返，从下一候补路径继续搜索，直至搜索到目标数据结束</li>
<li>候补顶点用“后入先出”栈来管理</li>
</ol>
<img src="img-17.png" width=100% height=200 alt=alt />

<img src="img-18.png" width=100% height=200 alt=alt />

<pre><code class="javascript">const &#123; tree &#125; = require(&quot;../../assets/mock/index&quot;);

// 利用栈后进先出的思想
function depthFirst(treeObj, target) &#123;
  if (!treeObj) return;

  const searchStep = [];
  const stack = [treeObj];

  while (stack.length) &#123;
    const currentNode = stack.pop();
    const &#123; name, children &#125; = currentNode;
    searchStep.push(name);

    if (name === target) &#123;
      return &#123; name, searchStep &#125;;
    &#125;
    for (let i = children.length - 1; i &gt;= 0; i--) &#123;
      // 从左树开始查找
      // for (let i = 0; i &lt; children.length; i++) &#123;  // 从右树开始查找
      stack.push(children[i]);
    &#125;
  &#125;
  return -1;
&#125;

console.log(depthFirst(tree, &quot;G&quot;));

// 利用递归的思想沿一棵树从上到下遍历
function depthFirst1(treeObj, target) &#123;
  const searchStep = [];
  let result = null;

  const dfs = (treeObj) =&gt; &#123;
    const &#123; name, children &#125; = treeObj;
    searchStep.push(name);

    if (name === target) &#123;
      return (result = &#123; name, searchStep &#125;);
    &#125;

    while (children.length) &#123;
      const currentNode = children.shift();
      !result &amp;&amp; dfs(currentNode);
    &#125;
  &#125;;

  dfs(treeObj);
  return result;
&#125;

console.log(depthFirst1(tree, &quot;G&quot;));
</code></pre>
<h3 id="二叉树先序遍历"><a href="#二叉树先序遍历" class="headerlink" title="二叉树先序遍历"></a>二叉树先序遍历</h3><ol>
<li>遍历树如下：</li>
</ol>
<img src="img-19.png" width=100% height=200 alt=alt />

<ol start="2">
<li>先序（先根）遍历：根-&gt;左-&gt;右，所以遍历顺序为 A-B-D-F-G-H-I-E-C</li>
</ol>
<pre><code class="javascript">// 利用栈迭代：O(n)
var preorderTraversal = function (root) &#123;
  let values = [];
  let stack = [root];
  while (stack.length) &#123;
    const node = stack.pop();
    const &#123; left, val, right &#125; = node;
    values.push(val);

    right &amp;&amp; stack.push(right);
    left &amp;&amp; stack.push(left);
  &#125;

  return values;
&#125;;
</code></pre>
<h3 id="二叉树中序遍历"><a href="#二叉树中序遍历" class="headerlink" title="二叉树中序遍历"></a>二叉树中序遍历</h3><ol>
<li>中序（中根）遍历：左-&gt;根-&gt;右，所以遍历顺序为 F-D-H-G-I-B-E-A-C</li>
</ol>
<pre><code class="javascript">// 采用递归：先递归左子树，返回根元素，再递归右子树， O(n)
var inorderTraversal = function (root) &#123;
  let values = [];

  const inorder = (root) =&gt; &#123;
    if (!root) return;
    inorder(root.left);
    values.push(root.val);
    inorder(root.right);
  &#125;;
  inorder(root);
  return values;
&#125;;
// 利用栈迭代解决：O(n)
var inorderTraversal1 = function (root) &#123;
  let values = [];
  let stack = [];

  while (root || stack.length) &#123;
    while (root) &#123;
      stack.push(root);
      root = root.left;
    &#125;
    const node = stack.pop();
    values.push(node.val);
    root = node.right;
  &#125;
  return values;
&#125;;
</code></pre>
<h3 id="二叉树后序遍历"><a href="#二叉树后序遍历" class="headerlink" title="二叉树后序遍历"></a>二叉树后序遍历</h3><ol>
<li>后序（后根）遍历：左-&gt;右-&gt;根，所以遍历顺序为 F-H-I-G-D-E-B-C-A</li>
</ol>
<pre><code class="javascript">var postorderTraversal = function (root) &#123;
  let values = [];
  let stack = [];
  while (root || stack.length) &#123;
    while (root) &#123;
      values.unshift(root.val);
      stack.push(root);
      root = root.right;
    &#125;
    root = stack.pop();
    root = root.left;
  &#125;
  return values;
&#125;;

// 采用递归：先递归左子树，再递归右子树，返回根元素， O(n)
var postorderTraversal1 = function (root) &#123;
  let values = [];
  const postorder = (root) =&gt; &#123;
    if (!root) return;
    postorder(root.left);
    postorder(root.right);
    values.push(root.val);
  &#125;;
  postorder(root);
  console.log(values, &quot;values&quot;);
&#125;;
</code></pre>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1593109">实现一个二叉搜索树</a></p>
<ol>
<li>定义：左子树不为空，则左子树所有节点值小于根节点；右子树不为空，则右子树所有节点值大于根节点</li>
<li>优点：插入、删除、查找更高效，平均时间复杂度为 O(logn)</li>
</ol>
<pre><code class="javascript">class BST &#123;
  constructor(root = null) &#123;
    this.root = root; // 初始化根节点
    this.count = 0; // 记录节点数量
    // 实例化一个 node 节点
    this.Node = function (value) &#123;
      return &#123;
        value,
        left: null,
        right: null,
      &#125;;
    &#125;;
  &#125;
  _insert(node, value) &#123;
    if (node === null) &#123;
      this.count++;
      return new this.Node(value);
    &#125;

    if (value === node.value) &#123;
      // 值相同的节点，如果是无重复二叉搜索树，则是更新节点操作
      console.log(&quot;duplicate node: &quot;, value);
    &#125; else if (value &lt; node.value) &#123;
      // 左子树插入节点
      node.left = this._insert(node.left, value);
    &#125; else &#123;
      // 右子树插入节点
      node.right = this._insert(node.right, value);
    &#125;
    return node;
  &#125;
  _minNode(node) &#123;
    while (node !== null) &#123;
      if (node.left === null) &#123;
        return node;
      &#125;
      node = node.left;
    &#125;
  &#125;
  _removeNode(node, value) &#123;
    // 1. 没找到，返回 null
    if (node === null) return null;
    // 2. 左侧节点递归查找删除节点
    if (value &lt; node.value) &#123;
      node.left = this._removeNode(node.left, value);
      return node;
    &#125;
    // 3. 右侧节点递归查找删除节点
    if (value &gt; node.value) &#123;
      node.right = this._removeNode(node.right, value);
      return node;
    &#125;
    // 4. value === node.value, 找到节点
    // 4.1 节点左右子树为 null 直接删除节点
    if (node.left === null &amp;&amp; node.right === null) &#123;
      node = null;
      this.count--;
      return node;
    &#125;
    // 4.2 节点只有左子树为 null 用右侧子树替换当前节点
    if (node.left === null) &#123;
      node = node.right;
      this.count--;
      return node;
    &#125;
    // 4.3 节点只有右子树为 null 用左侧子树替换当前节点
    if (node.right === null) &#123;
      node = node.left;
      this.count--;
      return node;
    &#125;
    // 4.4 节点左右子树都存在，需从右子树中找到最小节点替换当前节点，并删除最小节点
    let rightMinNodeValue = this._minNode(node.right).value;
    let dummy = new this.Node(rightMinNodeValue);
    dummy.left = node.left;
    dummy.right = this._removeNode(node.right, rightMinNodeValue);
    node = null;
    this.count--;
    // 返回 dummy 节点替代 node
    return dummy;
  &#125;
  // 插入节点
  insert(value) &#123;
    this.root = this._insert(this.root, value);
  &#125;
  // 查找节点
  search(value) &#123;
    let dummy = this.root;
    while (dummy !== null) &#123;
      if (value === dummy.value) &#123;
        return dummy;
      &#125; else if (value &gt; dummy.value) &#123;
        dummy = dummy.right;
      &#125; else &#123;
        dummy = dummy.left;
      &#125;
    &#125;
    return null;
  &#125;
  // 最小节点
  minNode() &#123;
    return this._minNode(this.root).value;
  &#125;
  // 最大节点
  maxNode() &#123;
    let dummy = this.root;
    while (dummy !== null) &#123;
      if (dummy.right === null) &#123;
        return dummy.value;
      &#125;
      dummy = dummy.right;
    &#125;
  &#125;
  // 移除节点
  removeNode(value) &#123;
    this.root = this._removeNode(this.root, value);
  &#125;
&#125;

const bst = new BST();
const testTree = [30, 25, 36, 20, 28, 32, 40, 27, 31, 34];
for (let i = 0; i &lt; testTree.length; i++) &#123;
  bst.insert(testTree[i]);
&#125;
// console.log(bst.root, &quot;bst&quot;);
// console.log(bst.search(322));
// console.log(bst.minNode());
// console.log(bst.maxNode());
console.log(bst.removeNode(30));
</code></pre>

  </div>
  <div id=""></div>
</div>

<script>
  
Fancybox.bind('[data-fancybox="fancybox-gallery-img"]', {
  dragToClose: true,
  Toolbar: true,
  closeButton: "top",
  Image: {
    zoom: true,
  },
  on: {
    initCarousel: (fancybox) => {
      const slide = fancybox.Carousel.slides[fancybox.Carousel.page];
      fancybox.$container.style.setProperty(
        "--bg-image",
        `url("${slide.$thumb.src}")`
      );
    },
    "Carousel.change": (fancybox, carousel, to, from) => {
      const slide = carousel.slides[to];
      fancybox.$container.style.setProperty(
        "--bg-image",
        `url("${slide.$thumb.src}")`
      );
    },
  },
});
</script>

<style>
    #noneimg img {
        display: none;
        z-index: 9999;
        /* width: 600px !important; */
        min-width: 0%;
        max-width: 90%;
        max-height: 80%;
        border-radius: 0px;
        position: fixed;
        box-shadow: 0 0 0px #c3c3c300 !important;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        margin: auto !important;
    }

    @media screen and (max-width:600px) {
        #noneimg img {
            max-width: 88%
        }
    }
</style>

    <div class="post-paging" style="display: none;">
    

    
    <a href="/2023/05/09/encrypt/">
        <div class="post-paging-next">
            <span>下一篇</span>
            <p>常见加密算法</p>
        </div>
    </a>
    
</div>
</div>
		
<div class="footer">
	<div class="Copyright">
		©2023 By Jia
	</div>
	<div class="contact">
		
		<a href="">
			<img src="/image/logo.png" alt="Quiet主题">
		</a>
		
	</div>
</div>

<script src="/js/gotop.js"></script>


<style type="text/css">
    @media screen and (min-width: 600px) {
        .goTop>span {
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            width: 40px;
            height: 40px;
            cursor: pointer;
            opacity: 0.8;
            background: rgba(18, 24, 58, 0.06);
            text-align: center;
            transition: border .5s;
            border: 1px solid rgba(18, 24, 58, 0.06);

            -moz-transition: border .5s;
            /* Firefox 4 */
            -webkit-transition: border .5s;
            /* Safari 和 Chrome */
            -o-transition: border .5s;
            /* Opera */
        }

        .goTop>span:hover {
            border: 1px solid #6680B3;
        }


        .goTop {
            position: fixed;
            right: 30px;
            bottom: 80px;
        }

        .goTop>span>svg {
            width: 20px;
            height: 20px;
            opacity: 0.7;
        }

    }

    @media screen and (max-width: 600px) {
        .goTop {
            display: none;
        }
    }
</style>
<div class="goTop" id="js-go_top">
    <span>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
            <g>
                <path d="M13 12v8h-2v-8H4l8-8 8 8z"></path>
            </g>
        </svg>
    </span>
</div>
<script>
    $( '#js-go_top' )
	.gotoTop( {
		offset: 500,
		speed: 300,
		animationShow: {
			'transform': 'translate(0,0)',
			'transition': 'transform .5s ease-in-out'
		},
		animationHide: {
			'transform': 'translate(100px,0)',
			'transition': 'transform .5s ease-in-out'
		}
	} );
</script>


    <!-- Gitalk -->
    <script>
        const data = '{"clientID":"02b3c","clientSecret":"adfc7b4","repo":"gimment","owner":"duneng","admin":"duneng"}'
        const gitalk = new Gitalk({
            ...JSON.parse( data),
            id:location.pathname,
            distractionFreeMode:false
        })
        
        if(Boolean('false')){
            gitalk.render('gitalk-container')
        }
    </script>

<script>
	console.log('\n %c Hexo-Quiet 主题 %c https://github.com/79e/hexo-theme-quiet \n', 'color: #fadfa3; background: #030307; padding:5px 0;', 'background: #fadfa3; padding:5px 0;')
</script>
	</body>
</html>

